Sunday, November 26, 2017
-------------------------

Spent a little time defining what templates should look like. I need to
a) make some test categories
b) define error conditions (e.g. substitute a missing category)

====================================
Saturday, December 16, 2017
====================================

Today's task is to simplify thing-a-day.

I think templates could either take the form of JSON,
where it's the callers job to then put the filled-in
template into a web page, tweet, email, or whatever,
or else it could be just text, in which case the 
template might actually be the body of whatever is
to be produced.

I think for now the simplest thing I could do
is make the template be just text (which could actually
be in JSON format, aside from substitutions).

Also, I can assume that I won't be running it as 
a service for multiple people, but that instead everyone
will run it themselves (or add auth themselves if they
want to support multiple people themselves).

So no auth required! That's such a huge
simplification, I think I may actually get this
done in the near future!

====================================
Friday, March 9, 2018
====================================

Boy, those were famous last words, huh?

I've been thinking about this project a lot over the
past couple of days, but haven't actually worked on 
it.

====================================
Saturday, March 10, 2018
====================================

go has an amazingly complete template package 
already: https://golang.org/pkg/text/template/

unfortunately, I don't want users to have to
learn anything that complicated, or get close
to writing go code themselves, in order to
use thing-a-day.

A template should just be a string containing
embedded formatting with special syntax for
substitutions. Templates can refer to other
templates. (Need to do loop detection)

Aha! It turns out that someone has made a go library 
for the mustache template language: https://github.com/cbroglie/mustache

I should be able to use a subset of that, and map
database elements (probably stored in a mongodb database)
into it.

I'll give that a shot. I'll play around with it
a bit first to see how it works.


====================================
Sunday, March 11, 2018
====================================

Let's learn by doing! I need a specific example app.

I'll replicate my creaky old Humorscope app, since I've been meaning
to for about 17 years now, anyway. Better late than later?

It looks something like this:

1) a web page with different content every day
2) an email (or mobile app text) with text specific to a user every day
3) a dozen tweets per day, one per zodiac sign 

The web page has a form something like this (if this was JSX instead of a template):

let signs = [Aries, Taurus, Gemini, Cancer, Leo, Virgo, Libra, Scorpio, Sagittarius, Capricorn, Aquarius, Pisces];
let predictions = [];
for (var s in signs) {
    predictions.push(<Prediction user="default" day="today" key={s} />);
}

<humorscope>
  <quote user="default" day="today" />
  <horoscope>
    <Predictions>{predictions}</Predictions>
  </horoscope>
</humorscope>

If a prediction didn't already exist for a user, for a day, for a sign, it would
pull one from the category and save it in the database with that composite key. Unless
there is not enough data, it would not ever re-use an element of a category for the 
same user and same day for two signs. It will try to not re-use an element of a category
for the same user for at least N days, where N is configurable for a category. Even 
then, it will try not to re-use an element of a category for the same sign for at least
M days, where M is probably longer than N.

For this example, it might be configured so that:
  a) choose 12 unique predictions, one per sign
  b) don't repeat any prediction for 14 days (assuming there are at least 14 * 12 predictions)
  c) don't repeat any prediction for the same sign for 100 days

Of course, now that I've written this down, I realize that plugging things into a template 
is not the interesting part, it's randomly returning a batch of results that matches
the constraints.

That would make a super nifty example GraphQL service!

Off to ponder that.
