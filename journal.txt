Sunday, November 26, 2017
-------------------------

Spent a little time defining what templates should look like. I need to
a) make some test categories
b) define error conditions (e.g. substitute a missing category)

====================================
Saturday, December 16, 2017
====================================

Today's task is to simplify thing-a-day.

I think templates could either take the form of JSON,
where it's the callers job to then put the filled-in
template into a web page, tweet, email, or whatever,
or else it could be just text, in which case the 
template might actually be the body of whatever is
to be produced.

I think for now the simplest thing I could do
is make the template be just text (which could actually
be in JSON format, aside from substitutions).

Also, I can assume that I won't be running it as 
a service for multiple people, but that instead everyone
will run it themselves (or add auth themselves if they
want to support multiple people themselves).

So no auth required! That's such a huge
simplification, I think I may actually get this
done in the near future!

====================================
Friday, March 9, 2018
====================================

Boy, those were famous last words, huh?

I've been thinking about this project a lot over the
past couple of days, but haven't actually worked on 
it.

====================================
Saturday, March 10, 2018
====================================

go has an amazingly complete template package 
already: https://golang.org/pkg/text/template/

unfortunately, I don't want users to have to
learn anything that complicated, or get close
to writing go code themselves, in order to
use thing-a-day.

A template should just be a string containing
embedded formatting with special syntax for
substitutions. Templates can refer to other
templates. (Need to do loop detection)

Aha! It turns out that someone has made a go library 
for the mustache template language: https://github.com/cbroglie/mustache

I should be able to use a subset of that, and map
database elements (probably stored in a mongodb database)
into it.

I'll give that a shot. I'll play around with it
a bit first to see how it works.


====================================
Sunday, March 11, 2018
====================================

Let's learn by doing! I need a specific example app.

I'll replicate my creaky old Humorscope app, since I've been meaning
to for about 17 years now, anyway. Better late than later?

It looks something like this:

1) a web page with different content every day
2) an email (or mobile app text) with text specific to a user every day
3) a dozen tweets per day, one per zodiac sign 

The web page has a form something like this (if this was JSX instead of a template):

let signs = [Aries, Taurus, Gemini, Cancer, Leo, Virgo, Libra, Scorpio, Sagittarius, Capricorn, Aquarius, Pisces];
let predictions = [];
for (var s in signs) {
    predictions.push(<Prediction user="default" day="today" key={s} />);
}

<humorscope>
  <quote user="default" day="today" />
  <horoscope>
    <Predictions>{predictions}</Predictions>
  </horoscope>
</humorscope>

If a prediction didn't already exist for a user, for a day, for a sign, it would
pull one from the category and save it in the database with that composite key. Unless
there is not enough data, it would not ever re-use an element of a category for the 
same user and same day for two signs. It will try to not re-use an element of a category
for the same user for at least N days, where N is configurable for a category. Even 
then, it will try not to re-use an element of a category for the same sign for at least
M days, where M is probably longer than N.

For this example, it might be configured so that:
  a) choose 12 unique predictions, one per sign
  b) don't repeat any prediction for 14 days (assuming there are at least 14 * 12 predictions)
  c) don't repeat any prediction for the same sign for 100 days

Of course, now that I've written this down, I realize that plugging things into a template 
is not the interesting part, it's randomly returning a batch of results that matches
the constraints.

That would make a super nifty example GraphQL service!

Off to ponder that.


====================================
Saturday, March 24, 2018
====================================

I've been tinkering with humorscope for a bit, getting ready to use this
thing-a-day project's REST API to populate it. I think I'm about ready.

I think what I'll do first is create a schema and load some data manually,
and get the consumer REST APIs working first.

[ ] make a schema
[ ] load some data
[ ] make / test the REST API to retrieve data
[ ] make a docker image
[ ] test/debug/integrate with humorscope

I'm starting by making a db called thing-a-day in my local mongodb, with
collections predictions and quotes. In a hosted service, I'd need to make
separate databases (I guess?) for each user, but I'm just making a 
sample.

> show collections
predictions
quotes
> show dbs
local        0.000GB
sideauth     0.000GB
thing-a-day  0.000GB

Now to try to load the initial data for those. Switching to the humorscope 
project for that.

I got the predictions loaded, but now I realize I need a way to randomly
pick them, which means I need to add a field that is just a counter (probably).

I'm stopping for now to research randomly picking records from the database.

Aha! Looks like there's a "sample" operator there already, so there's no
need to add a new field. Hopefully.

// Get one random document from the mycoll collection.
db.mycoll.aggregate(
   { $sample: { size: 1 } }
)

This worked!
use thing-a-day
db.predictions.aggregate({ $sample: {size: 10}})


====================================
Sunday, March 25, 2018
====================================

I need to load the quote data still. I think I'll try doing that with pymongo,
since the form I have it in is not csv/tsv/json but it looks easily parseable.

====================================
Monday, March 26, 2018
====================================

I wrote a pymongo script to load the initial quotes for humorscope yesterday,
so now it's time to start doing some TDD development on thing-a-day!

First, I'll just make a stub function to return N records from a named collection
of a default database. I'll figure out how to open the database once that is failing.

Done!

====================================
Wednesday, March 28, 2018
====================================

Wrote a handler for getrecords and tested it with:
http://localhost:8084/records/predictions/prediction/5

====================================
Thursday, March 29, 2018
====================================

Moved the handler to its own file.

====================================
Friday, March 30, 2018
====================================

Getting started on a test for the GET handler.

====================================
Sunday, April 1, 2018
====================================
I started trying to Dockerize this. I made a Dockerfile,
but I think it needs work to map the mongo ports and set 
up a volume.

Start here tomorrow:
https://www.thachmai.info/2015/04/30/running-mongodb-container/

====================================
Sunday, April 8, 2018
====================================

I added a db directory and scripts to dump/restore mongo,
but I'm having trouble mapping the ports for reaching mongo
on port 37017 from the thing-a-day container:

docker: Error response from daemon: driver failed programming external connectivity on endpoint thing-a-day (3893c904314b8120f797f30d7795d6ca5a5351b9e5dbb47c1ff7c418c605cec6): Bind for 0.0.0.0:37017 failed: port is already allocated.

Giving up for tonight.
