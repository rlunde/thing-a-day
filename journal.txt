Sunday, November 26, 2017
-------------------------

Spent a little time defining what templates should look like. I need to
a) make some test categories
b) define error conditions (e.g. substitute a missing category)

====================================
Saturday, December 16, 2017
====================================

Today's task is to simplify thing-a-day.

I think templates could either take the form of JSON,
where it's the callers job to then put the filled-in
template into a web page, tweet, email, or whatever,
or else it could be just text, in which case the 
template might actually be the body of whatever is
to be produced.

I think for now the simplest thing I could do
is make the template be just text (which could actually
be in JSON format, aside from substitutions).

Also, I can assume that I won't be running it as 
a service for multiple people, but that instead everyone
will run it themselves (or add auth themselves if they
want to support multiple people themselves).

So no auth required! That's such a huge
simplification, I think I may actually get this
done in the near future!

====================================
Friday, March 9, 2018
====================================

Boy, those were famous last words, huh?

I've been thinking about this project a lot over the
past couple of days, but haven't actually worked on 
it.

====================================
Saturday, March 10, 2018
====================================

go has an amazingly complete template package 
already: https://golang.org/pkg/text/template/

unfortunately, I don't want users to have to
learn anything that complicated, or get close
to writing go code themselves, in order to
use thing-a-day.

A template should just be a string containing
embedded formatting with special syntax for
substitutions. Templates can refer to other
templates. (Need to do loop detection)

Aha! It turns out that someone has made a go library 
for the mustache template language: https://github.com/cbroglie/mustache

I should be able to use a subset of that, and map
database elements (probably stored in a mongodb database)
into it.

I'll give that a shot. I'll play around with it
a bit first to see how it works.


====================================
Sunday, March 11, 2018
====================================

Let's learn by doing! I need a specific example app.

I'll replicate my creaky old Humorscope app, since I've been meaning
to for about 17 years now, anyway. Better late than later?

It looks something like this:

1) a web page with different content every day
2) an email (or mobile app text) with text specific to a user every day
3) a dozen tweets per day, one per zodiac sign 

The web page has a form something like this (if this was JSX instead of a template):

let signs = [Aries, Taurus, Gemini, Cancer, Leo, Virgo, Libra, Scorpio, Sagittarius, Capricorn, Aquarius, Pisces];
let predictions = [];
for (var s in signs) {
    predictions.push(<Prediction user="default" day="today" key={s} />);
}

<humorscope>
  <quote user="default" day="today" />
  <horoscope>
    <Predictions>{predictions}</Predictions>
  </horoscope>
</humorscope>

If a prediction didn't already exist for a user, for a day, for a sign, it would
pull one from the category and save it in the database with that composite key. Unless
there is not enough data, it would not ever re-use an element of a category for the 
same user and same day for two signs. It will try to not re-use an element of a category
for the same user for at least N days, where N is configurable for a category. Even 
then, it will try not to re-use an element of a category for the same sign for at least
M days, where M is probably longer than N.

For this example, it might be configured so that:
  a) choose 12 unique predictions, one per sign
  b) don't repeat any prediction for 14 days (assuming there are at least 14 * 12 predictions)
  c) don't repeat any prediction for the same sign for 100 days

Of course, now that I've written this down, I realize that plugging things into a template 
is not the interesting part, it's randomly returning a batch of results that matches
the constraints.

That would make a super nifty example GraphQL service!

Off to ponder that.


====================================
Saturday, March 24, 2018
====================================

I've been tinkering with humorscope for a bit, getting ready to use this
thing-a-day project's REST API to populate it. I think I'm about ready.

I think what I'll do first is create a schema and load some data manually,
and get the consumer REST APIs working first.

[ ] make a schema
[ ] load some data
[ ] make / test the REST API to retrieve data
[ ] make a docker image
[ ] test/debug/integrate with humorscope

I'm starting by making a db called thing-a-day in my local mongodb, with
collections predictions and quotes. In a hosted service, I'd need to make
separate databases (I guess?) for each user, but I'm just making a 
sample.

> show collections
predictions
quotes
> show dbs
local        0.000GB
sideauth     0.000GB
thing-a-day  0.000GB

Now to try to load the initial data for those. Switching to the humorscope 
project for that.

I got the predictions loaded, but now I realize I need a way to randomly
pick them, which means I need to add a field that is just a counter (probably).

I'm stopping for now to research randomly picking records from the database.

Aha! Looks like there's a "sample" operator there already, so there's no
need to add a new field. Hopefully.

// Get one random document from the mycoll collection.
db.mycoll.aggregate(
   { $sample: { size: 1 } }
)

This worked!
use thing-a-day
db.predictions.aggregate({ $sample: {size: 10}})


====================================
Sunday, March 25, 2018
====================================

I need to load the quote data still. I think I'll try doing that with pymongo,
since the form I have it in is not csv/tsv/json but it looks easily parseable.

====================================
Monday, March 26, 2018
====================================

I wrote a pymongo script to load the initial quotes for humorscope yesterday,
so now it's time to start doing some TDD development on thing-a-day!

First, I'll just make a stub function to return N records from a named collection
of a default database. I'll figure out how to open the database once that is failing.

Done!

====================================
Wednesday, March 28, 2018
====================================

Wrote a handler for getrecords and tested it with:
http://localhost:8084/records/predictions/prediction/5

====================================
Thursday, March 29, 2018
====================================

Moved the handler to its own file.

====================================
Friday, March 30, 2018
====================================

Getting started on a test for the GET handler.

====================================
Sunday, April 1, 2018
====================================
I started trying to Dockerize this. I made a Dockerfile,
but I think it needs work to map the mongo ports and set 
up a volume.

Start here tomorrow:
https://www.thachmai.info/2015/04/30/running-mongodb-container/

====================================
Sunday, April 8, 2018
====================================

I added a db directory and scripts to dump/restore mongo,
but I'm having trouble mapping the ports for reaching mongo
on port 37017 from the thing-a-day container:

docker: Error response from daemon: driver failed programming external connectivity on endpoint thing-a-day (3893c904314b8120f797f30d7795d6ca5a5351b9e5dbb47c1ff7c418c605cec6): Bind for 0.0.0.0:37017 failed: port is already allocated.

Giving up for tonight.

====================================
Monday, April 9, 2018
====================================

I did some docker reading in the middle of the night, so I have
a networking trick to try. I hope it works!!

Dang.
2018/04/10 02:39:05 mgo.Dial returned error no reachable servers

I tried a bunch of things. Giving up again (too late).

====================================
Tuesday, April 10, 2018
====================================

I've tried reading https://forums.docker.com/t/connect-to-mongo-in-docker/47275/6
a few times. It appears to be written in pure gibberish, and Google translate is
no help this time. I've tried a bunch of different things, with no luck.

Nothing. I got nothing. Boy, this docker thing sure is simple. Hours spent, and
nothing.

Maybe tomorrow.

====================================
Wednesday, April 11, 2018
====================================

I had no trouble, initially, getting mongo running in docker and mapping the
standard port inside the image to a port on the host, then interacting with
it with scripts running on the host.

I wonder if I can figure out how to get thing-a-day to connect to the mongo
running on the host? Then I'll have two sides working against the host, and
maybe it will occur to me how to get them to talk together.

I finally figured out what the problem was, sort of. It turned out to be go,
not docker, and not mongo. If I run mongo in the container like:

docker run -d -p 37017:27017 --rm --name tadmongo -v $MONGO_DATA_PATH:/data/db mongo

Then if I run ./service/thing-a-day directly (not in a container) it is able to
connect to mongo fine on port 37017. Nothing I've tried has got me past network 
issues when trying to run inside a container. I don't understand the info on 
this completely, but this stuff in the go community seems to imply that people 
are having the same trouble with kubernetes and other container infrastructure.

https://github.com/go-mgo/mgo/issues/341

Anyway, the networking stuff for docker is quite complicated, so I'm sure it's 
somehow a factor, but I don't want to spend more days trying to figure it out. 
I thought it would be cool to run my service in a container, but it's not cool
enough to derail everything else I want to do.

I suspect it's easy to call into a container with mapped ports, just hard to 
call out, at least in some way that mongo's Dial interface wants to do. Who 
knows?

For now, I'm giving up on this part.

====================================
Thursday, April 12, 2018
====================================

I think when I get back to the Docker part of this, I'll see if I can put
both mongo and thing-a-day into the same container using Docker compose. I know 
most people say you should have each thing in its own container, but that would 
have the advantage of being a single thing to download/deploy/run. We'll see.

====================================
Friday, April 13, 2018
====================================

I switched the service to read off the standard mongo port (27017) and 
localhost for now. Here's a URL to test that it's running:
http://localhost:8084/records/predictions/prediction/5

Now I want to add some APIs that are better suited for what I want.
a) cache results by user / day
b) allow a set of N results, all unique
c) don't repeat individual results for as long as possible

Maybe I need a specification template? Something like:

{
  "template":"humorscope",
  "user":"default",
  "frequency":"daily",
  "timezone":"-0400",
  "collections":{
    "predictions": {
      "number": 12,
      "unique": true,
      ...
    }
  }
}

====================================
Saturday, April 14, 2018
====================================

Actually, a simpler approach is just to make the date/time
REST (or GraphQL) parameters, and just create a record like:

key = user/template/collection/number/time
value = set of elements of collection

I'm going to try doing that for a first cut.

That means the main problems to solve from the thing-a-day
side are:
  a) get a set of N items randomly selected with no duplicates
  b) avoid picking any items that were recently used by the same 
     user and same template. 

Let's say there are 300 predictions, and 12 needed per day, then
it would be reasonable to not have any repeats for 20 days at least.

That's a hard enough problem to solve for a first phase.

====================================
Monday, April 16, 2018
====================================

Let's break that down.

1) Trim recently used list
  a) if number of items remaining is less than N, remove oldest items from recently used
  b) if items in recently used are older than D days, remove them anyway
2) Get N items
3) For each item, see if it has been recently used
  a) put in keepers list if not
  b) make sure it's not already in keepers list
4) Continue to get M items (N minus number of keepers) until full
5) Put N items in recently used list
6) Return N items

====================================
Wednesday, May 2, 2018
====================================

The big problem is what if we don't have enough items yet.

a) don't have enough items to even get the N we want
b) don't have enough items to get N that haven't been used in D days

