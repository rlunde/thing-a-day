Sunday, November 26, 2017
-------------------------

Spent a little time defining what templates should look like. I need to
a) make some test categories
b) define error conditions (e.g. substitute a missing category)

====================================
Saturday, December 16, 2017
====================================

Today's task is to simplify thing-a-day.

I think templates could either take the form of JSON,
where it's the callers job to then put the filled-in
template into a web page, tweet, email, or whatever,
or else it could be just text, in which case the 
template might actually be the body of whatever is
to be produced.

I think for now the simplest thing I could do
is make the template be just text (which could actually
be in JSON format, aside from substitutions).

Also, I can assume that I won't be running it as 
a service for multiple people, but that instead everyone
will run it themselves (or add auth themselves if they
want to support multiple people themselves).

So no auth required! That's such a huge
simplification, I think I may actually get this
done in the near future!

====================================
Friday, March 9, 2018
====================================

Boy, those were famous last words, huh?

I've been thinking about this project a lot over the
past couple of days, but haven't actually worked on 
it.

====================================
Saturday, March 10, 2018
====================================

go has an amazingly complete template package 
already: https://golang.org/pkg/text/template/

unfortunately, I don't want users to have to
learn anything that complicated, or get close
to writing go code themselves, in order to
use thing-a-day.

A template should just be a string containing
embedded formatting with special syntax for
substitutions. Templates can refer to other
templates. (Need to do loop detection)

Aha! It turns out that someone has made a go library 
for the mustache template language: https://github.com/cbroglie/mustache

I should be able to use a subset of that, and map
database elements (probably stored in a mongodb database)
into it.

I'll give that a shot. I'll play around with it
a bit first to see how it works.

